---
title: "SignallingSingleCell"
geometry: margin=0.5cm
author: "Kyle Gellatly"
date: "`r Sys.Date()`"
output:
html_document:
  highlight: tango
  theme: cerulean
  toc: yes
  toc_float : yes
---

```{r setup, include=FALSE, warning=FALSE, error=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "")
```


```{r, include=FALSE, cache=FALSE, warning=FALSE, error=FALSE}
library("SignallingSingleCell")
load(url("https://galaxyweb.umassmed.edu/pub/class/mDC_UMI_Table.Rdata"))
load(url("https://galaxyweb.umassmed.edu/pub/class/ex_sc_skin.Rdata"))
```

# Preprocessing  

## Constructing the ExpressionSet Class  

The ExpressionSet class (ex_sc) is a convenient data structure that contains 3 dataframes. These dataframes contain expression data, cell information, and gene information respectively. 

exprs(ex_sc) is the expression data, where rows are genes and columns are cells  
pData(ex_sc) is cell information, where rows are cells and columns are metadata  
fData(ex_sc) is gene information, where rows are genes and columns are metadata

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
ex_sc <- construct_ex_sc(mDC_UMI_Table) # sc_dat == Input expression matrix
ex_sc # Note that phenoData and featureData are empty right now!
rm(mDC_UMI_Table)
```

## Data Annotation

Often we have metadata about the experiment that can be valuable in the analysis! Writing that information now may be appropriate. Our experiment consists of a time course with LPS stimulation.

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
pData(ex_sc)$Timepoint <- NA # initialize a new pData column

pData(ex_sc)[grep("0hr", rownames(pData(ex_sc))),"Timepoint"] <- "0hr"
pData(ex_sc)[grep("1hr", rownames(pData(ex_sc))),"Timepoint"] <- "1hr"
pData(ex_sc)[grep("4hr", rownames(pData(ex_sc))),"Timepoint"] <- "4hr"

head(pData(ex_sc))
```

## Filtering

The first step is to filter your data to remove low quality cells. Often creating a histogram of the values and assigning cutoffs is simple and effective. Typically we remove all cells lower than 500-1000 UMIs / cell.

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
ex_sc <- calc_libsize(ex_sc, suffix = "raw") # sums counts for each cell
plot_density(ex_sc, title = "UMI Density", val = "UMI_sum_raw", statistic = "mean") # Density function. Note how many low UMI count cells are in the data!

ex_sc <- pre_filter(ex_sc, minUMI = 1000, maxUMI = 10000, threshold = 1, minCells = 10,  print_progress = TRUE) # filters cells and genes
ex_sc <- calc_libsize(ex_sc, suffix = "raw_filtered")
plot_density(ex_sc, title = "UMI Density",  val = "UMI_sum_raw_filtered", statistic = "mean")  

# save_ggplot(filename = "Density", format = "pdf") # Plots can be quickly and easily saved!
```

# Basic scRNA-seq analysis  

## Dimension reduction

Dimensionality reduction is necessary in order to bring the cells from a high dimensional gene expression space (~10k dimensions) down to a more reasonable number. Typically this is done first with PCA ~5-15 dimensions, before a final embedding is done using tSNE or UMAP to bring it down to 2 dimensions. 

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
gene_subset <- subset_genes(ex_sc, method = "PCA", threshold = 1, minCells = 20, nComp = 10, cutoff = 0.85) 

ex_sc <- dim_reduce(ex_sc, genelist = gene_subset, pre_reduce = "iPCA", nComp = 10, tSNE_perp = 30, iterations = 500, print_progress=TRUE) 

colnames(pData(ex_sc))

plot_tsne_metadata(ex_sc, color_by = "UMI_sum_raw", title = "Total UMIs per cell") 

plot_tsne_metadata(ex_sc, color_by = "iPC_Comp1", title = "PC1 cell loadings") 

plot_tsne_metadata(ex_sc, color_by = "iPC_Comp2", title = "PC2 cell loadings") 

plot_tsne_metadata(ex_sc, color_by = "iPC_Comp3", title = "PC3 cell loadings") 

```
### Dimension reduction - Skin Data

Now let us try dimension for the skin data!!

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}

# gene_subset <- subset_genes(ex_sc_skin) 

# ex_sc_skin <- dim_reduce(ex_sc_skin) 

```


## Clustering

Now that we have dimension reduced data we can try clustering it!

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
ex_sc <- cluster_sc(ex_sc, dimension = "Comp", method = "spectral", num_clust = 5) # 2 clustering algorithms can be performed on 2d plots or PCA / ICA components

plot_tsne_metadata(ex_sc, color_by = "Cluster", title = "Spectral Cluster on iPCA components") # this function is flexible for plotting any data onto a 2d tsne mapping

plot_tsne_metadata(ex_sc, color_by = "Timepoint", title = "Spectral Cluster on iPCA components") # this function is flexible for plotting any data onto a 2d tsne mapping
```

### Clustering - Skin Data

Now let us try clustering for the skin data!! For dimensions, both Comp and 2d are supported. There will determine if the clustering is done on principal components, or on the 2D representation. There are also 2 clustering algorithms available, density and spectral. Typically we recommend spectral clustering on PCA components, or density clustering on the 2d representation. Try both!

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}

# ex_sc_skin <- cluster_sc(ex_sc_skin) 

```

## Cell Type Identification

There are many possible ways to identify cell types based on their gene expression. The id_markers function will identify genes that are highly expressed in a high proportion of a given cluster, relative to the other clusters.

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
ex_sc <- id_markers(ex_sc, print_progress = TRUE) # This is a quick method to find good markers genes for cell identification. These gene scores get written to fData()

markers <- return_markers(ex_sc, num_markers = 10) # This is a quick method to find good markers genes for cell identification. These gene scores get written to fData()

ex_sc <- calc_agg_bulk(ex_sc, aggregate_by = "Cluster")

plot_heatmap(ex_sc, genes = unique(unlist(markers)), type = "bulk")
```
### Clustering + Cell Type identification Skin Data

Now let us try clustering for the skin data!! For dimensions, both Comp and 2d are supported. There will determine if the clustering is done on principal components, or on the 2D representation. There are also 2 clustering algorithms available, density and spectral. Typically we recommend spectral clustering on PCA components, or density clustering on the 2d representation. Try both!

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}

# gene_subset <- cluster_sc(ex_sc_skin) 
# ex_sc_skin <- id_markers(ex_sc_skin)
# markers <- return_markers(ex_sc_skin) 
# ex_sc_skin <- calc_agg_bulk(ex_sc_skin)
# plot_heatmap(ex_sc_skin)

```

## Normalization

Now that the data has preliminary clusters, we can normalize. SCRAN normalization will first normalize internally in clusters, before normalizing across clusters. Once the data is normalized we can run the same steps as above before visualization. The first step is to select the genes to be used for normalization. One method would be to first only use genes expressed in more than n cells, and then remove the most variable genes. This method can be computationally expensive, and is currently commented out. A simpler approach, counts per million, is also provided below.

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
table(pData(ex_sc)$Cluster)

# ex_sc_norm <- norm_sc(ex_sc, pool_sizes = c(20,25,30,35,40))

x <- exprs(ex_sc)
cSum <- apply(x,2,sum)    # recompute for remaining cells
x <- as.matrix(sweep(x,2,cSum,FUN='/'))*1e6    # normalize to UMIs per million
ex_sc_norm <- construct_ex_sc(x)
pData(ex_sc_norm) <- pData(ex_sc)
```

## Post Normalization Pre-processing

Now that we have normalized, it is time to reprocess the data as before, this time on the normalized counts!

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}

# gene_subset <- subset_genes()

# ex_sc_norm <- dim_reduce()

# ex_sc_norm <- cluster_sc()

# plot_tsne_metadata()

# plot_tsne_gene()

```

# Advanced scRNA-seq analysis  

## Supervised Analysis

From the above analysis, it is clear that some clusters are formed based on their cell type, while others are based on their experimental condition. In these cases it can be useful to incorporate prior information in order to obtain clusters and annotations that are grounded in biological significance. Below, we can assign "panels" similar to flow cytometry, that will enable cell groupings based on the expression of genes that you believe to signify biologically relevenant cell types.

```{r, error=FALSE, warning=FALSE, cache=FALSE, include=TRUE}

panel1 <- c("S100a9", "Chil1") # Neutrophil Markers
panel2 <- c("Ccr7", "Fscn1") # DC
panel3 <- c("Csf1r", "Mertk") # Mac

panels <- list(panel1, panel2, panel3)

plot_tsne_gene(ex_sc_norm, gene = unlist(panels), title = "", log_scale = T)

names(panels) <- c("Neutrophil", "Dendritic", "Macrophage")

ex_sc_norm <- flow_filter(ex_sc_norm, panels = panels, title = "Flow Pass Cells")

ex_sc_norm <- flow_svm(ex_sc_norm, pcnames = "Comp")

plot_tsne_metadata(ex_sc_norm, color_by = "Cluster", title = "Spectral Cluster on PCA components")
plot_tsne_metadata(ex_sc_norm, color_by = "SVM_Classify", title = "Spectral Cluster on PCA components")

```

## DE analysis

Now that cells are grouped by their cell type, we can run DE in order to determine which genes are change in association with our experimental conditions. 

For simplicity we can subset to 0hr and 4hr, to  find the genes that change between these conditions.

It should be noted that DE should always be run on raw counts, not on the normalized counts!

```{r, error=FALSE, warning=FALSE, cache=FALSE, include=TRUE}

### Subsettting data is performed by providing a pData variable on which to subset, and the values you wish to select!

findDEgenes2(input = ex_sc,
            contrastID = "0hr",
            pd = pData(ex_sc_norm),
            DEgroup = "Timepoint",
            facet_by = "SVM_Classify")


```
